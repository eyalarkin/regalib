{
  "$schema": "https://docs.oasis-open.org/sarif/sarif/v2.1.0/os/schemas/sarif-schema-2.1.0.json",
  "runs": [
    {
      "invocations": [
        {
          "executionSuccessful": true,
          "toolExecutionNotifications": []
        }
      ],
      "results": [
        {
          "fingerprints": {
            "matchBasedId/v1": "c45e5ba35b43d8c3b33f13dcb636efeef718043db1da89832f7e50f9259c84dbd3602e531e2fad35b54a4fd0e4b04c3bb12d034909ebf2f95800ec642186099c_0"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "_build/default/src/lexer.ml",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "endColumn": 25,
                  "endLine": 45,
                  "snippet": {
                    "text": "| h :: t -> if h == '\\\"' then help t else h :: help t"
                  },
                  "startColumn": 16,
                  "startLine": 45
                }
              }
            }
          ],
          "message": {
            "text": "You probably want the structural equality operator ="
          },
          "properties": {},
          "ruleId": "ocaml.lang.correctness.physical-vs-structural.physical-equal"
        },
        {
          "fingerprints": {
            "matchBasedId/v1": "c45e5ba35b43d8c3b33f13dcb636efeef718043db1da89832f7e50f9259c84dbd3602e531e2fad35b54a4fd0e4b04c3bb12d034909ebf2f95800ec642186099c_1"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "_build/default/src/lexer.ml",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "endColumn": 54,
                  "endLine": 60,
                  "snippet": {
                    "text": "| h :: t -> if odd qc then (h :: help t (if h == '\\\"' then qc + 1 else qc))  else (if (whitespace h) then (help t qc) else (h :: help t (if h == '\\\"' then qc + 1 else qc)))"
                  },
                  "startColumn": 45,
                  "startLine": 60
                }
              }
            }
          ],
          "message": {
            "text": "You probably want the structural equality operator ="
          },
          "properties": {},
          "ruleId": "ocaml.lang.correctness.physical-vs-structural.physical-equal"
        },
        {
          "fingerprints": {
            "matchBasedId/v1": "c45e5ba35b43d8c3b33f13dcb636efeef718043db1da89832f7e50f9259c84dbd3602e531e2fad35b54a4fd0e4b04c3bb12d034909ebf2f95800ec642186099c_2"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "_build/default/src/lexer.ml",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "endColumn": 150,
                  "endLine": 60,
                  "snippet": {
                    "text": "| h :: t -> if odd qc then (h :: help t (if h == '\\\"' then qc + 1 else qc))  else (if (whitespace h) then (help t qc) else (h :: help t (if h == '\\\"' then qc + 1 else qc)))"
                  },
                  "startColumn": 141,
                  "startLine": 60
                }
              }
            }
          ],
          "message": {
            "text": "You probably want the structural equality operator ="
          },
          "properties": {},
          "ruleId": "ocaml.lang.correctness.physical-vs-structural.physical-equal"
        },
        {
          "fingerprints": {
            "matchBasedId/v1": "c96985169cfbfd6328272eb087f80ce6666f0a57206d7ae19aabc3d8b417035fa19417f95d47fa98d65ea0316c66b05513a763c27407aa5d7e58f2fa16430ac9_0"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/lexer.ml",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "endColumn": 25,
                  "endLine": 45,
                  "snippet": {
                    "text": "| h :: t -> if h == '\\\"' then help t else h :: help t"
                  },
                  "startColumn": 16,
                  "startLine": 45
                }
              }
            }
          ],
          "message": {
            "text": "You probably want the structural equality operator ="
          },
          "properties": {},
          "ruleId": "ocaml.lang.correctness.physical-vs-structural.physical-equal"
        },
        {
          "fingerprints": {
            "matchBasedId/v1": "c96985169cfbfd6328272eb087f80ce6666f0a57206d7ae19aabc3d8b417035fa19417f95d47fa98d65ea0316c66b05513a763c27407aa5d7e58f2fa16430ac9_1"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/lexer.ml",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "endColumn": 54,
                  "endLine": 60,
                  "snippet": {
                    "text": "| h :: t -> if odd qc then (h :: help t (if h == '\\\"' then qc + 1 else qc))  else (if (whitespace h) then (help t qc) else (h :: help t (if h == '\\\"' then qc + 1 else qc)))"
                  },
                  "startColumn": 45,
                  "startLine": 60
                }
              }
            }
          ],
          "message": {
            "text": "You probably want the structural equality operator ="
          },
          "properties": {},
          "ruleId": "ocaml.lang.correctness.physical-vs-structural.physical-equal"
        },
        {
          "fingerprints": {
            "matchBasedId/v1": "c96985169cfbfd6328272eb087f80ce6666f0a57206d7ae19aabc3d8b417035fa19417f95d47fa98d65ea0316c66b05513a763c27407aa5d7e58f2fa16430ac9_2"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/lexer.ml",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "endColumn": 150,
                  "endLine": 60,
                  "snippet": {
                    "text": "| h :: t -> if odd qc then (h :: help t (if h == '\\\"' then qc + 1 else qc))  else (if (whitespace h) then (help t qc) else (h :: help t (if h == '\\\"' then qc + 1 else qc)))"
                  },
                  "startColumn": 141,
                  "startLine": 60
                }
              }
            }
          ],
          "message": {
            "text": "You probably want the structural equality operator ="
          },
          "properties": {},
          "ruleId": "ocaml.lang.correctness.physical-vs-structural.physical-equal"
        },
        {
          "fingerprints": {
            "matchBasedId/v1": "d79ff787ff62d4f4771af851fe99cd5659849928415492fbcc9ed9449606e1953c06abde13a919a31f5258fe6240db48d68736915f83631e86f987f67168eb9a_0"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "_build/default/src/lexer.ml",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "endColumn": 25,
                  "endLine": 45,
                  "snippet": {
                    "text": "| h :: t -> if h == '\\\"' then help t else h :: help t"
                  },
                  "startColumn": 16,
                  "startLine": 45
                }
              }
            }
          ],
          "message": {
            "text": "You probably want the structural inequality operator ="
          },
          "properties": {},
          "ruleId": "ocaml.lang.correctness.physical_vs_structural.physical-equal"
        },
        {
          "fingerprints": {
            "matchBasedId/v1": "d79ff787ff62d4f4771af851fe99cd5659849928415492fbcc9ed9449606e1953c06abde13a919a31f5258fe6240db48d68736915f83631e86f987f67168eb9a_1"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "_build/default/src/lexer.ml",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "endColumn": 54,
                  "endLine": 60,
                  "snippet": {
                    "text": "| h :: t -> if odd qc then (h :: help t (if h == '\\\"' then qc + 1 else qc))  else (if (whitespace h) then (help t qc) else (h :: help t (if h == '\\\"' then qc + 1 else qc)))"
                  },
                  "startColumn": 45,
                  "startLine": 60
                }
              }
            }
          ],
          "message": {
            "text": "You probably want the structural inequality operator ="
          },
          "properties": {},
          "ruleId": "ocaml.lang.correctness.physical_vs_structural.physical-equal"
        },
        {
          "fingerprints": {
            "matchBasedId/v1": "d79ff787ff62d4f4771af851fe99cd5659849928415492fbcc9ed9449606e1953c06abde13a919a31f5258fe6240db48d68736915f83631e86f987f67168eb9a_2"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "_build/default/src/lexer.ml",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "endColumn": 150,
                  "endLine": 60,
                  "snippet": {
                    "text": "| h :: t -> if odd qc then (h :: help t (if h == '\\\"' then qc + 1 else qc))  else (if (whitespace h) then (help t qc) else (h :: help t (if h == '\\\"' then qc + 1 else qc)) )"
                  },
                  "startColumn": 141,
                  "startLine": 60
                }
              }
            }
          ],
          "message": {
            "text": "You probably want the structural inequality operator ="
          },
          "properties": {},
          "ruleId": "ocaml.lang.correctness.physical_vs_structural.physical-equal"
        },
        {
          "fingerprints": {
            "matchBasedId/v1": "642f1b030b9e9e63c82f48e83143e3fe3804f84e28974118f7c3b1ab86774949c39ec5b8bfcc3ef8395c645bf168e9aa71e9f2de3aa52d1ddb846e4857a91f99_0"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/lexer.ml",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "endColumn": 25,
                  "endLine": 45,
                  "snippet": {
                    "text": "| h :: t -> if h == '\\\"' then help t else h :: help t"
                  },
                  "startColumn": 16,
                  "startLine": 45
                }
              }
            }
          ],
          "message": {
            "text": "You probably want the structural inequality operator ="
          },
          "properties": {},
          "ruleId": "ocaml.lang.correctness.physical_vs_structural.physical-equal"
        },
        {
          "fingerprints": {
            "matchBasedId/v1": "642f1b030b9e9e63c82f48e83143e3fe3804f84e28974118f7c3b1ab86774949c39ec5b8bfcc3ef8395c645bf168e9aa71e9f2de3aa52d1ddb846e4857a91f99_1"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/lexer.ml",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "endColumn": 54,
                  "endLine": 60,
                  "snippet": {
                    "text": "| h :: t -> if odd qc then (h :: help t (if h == '\\\"' then qc + 1 else qc))  else (if (whitespace h) then (help t qc) else (h :: help t (if h == '\\\"' then qc + 1 else qc)))"
                  },
                  "startColumn": 45,
                  "startLine": 60
                }
              }
            }
          ],
          "message": {
            "text": "You probably want the structural inequality operator ="
          },
          "properties": {},
          "ruleId": "ocaml.lang.correctness.physical_vs_structural.physical-equal"
        },
        {
          "fingerprints": {
            "matchBasedId/v1": "642f1b030b9e9e63c82f48e83143e3fe3804f84e28974118f7c3b1ab86774949c39ec5b8bfcc3ef8395c645bf168e9aa71e9f2de3aa52d1ddb846e4857a91f99_2"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/lexer.ml",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "endColumn": 150,
                  "endLine": 60,
                  "snippet": {
                    "text": "| h :: t -> if odd qc then (h :: help t (if h == '\\\"' then qc + 1 else qc))  else (if (whitespace h) then (help t qc) else (h :: help t (if h == '\\\"' then qc + 1 else qc)))"
                  },
                  "startColumn": 141,
                  "startLine": 60
                }
              }
            }
          ],
          "message": {
            "text": "You probably want the structural inequality operator ="
          },
          "properties": {},
          "ruleId": "ocaml.lang.correctness.physical_vs_structural.physical-equal"
        },
        {
          "fingerprints": {
            "matchBasedId/v1": "ad7463ebad471b6720ac6352ac9316c9aaa574b620f403021b415d164678918447852b3af296b17a3af0be3b3d30aaa956eccc353145ec7d14c92836b79792a3_0"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "_build/default/src/utils.ml",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "endColumn": 28,
                  "endLine": 92,
                  "snippet": {
                    "text": "      try Some ((input_line ic) ^ \"\\n\") with End_of_file -> None in"
                  },
                  "startColumn": 18,
                  "startLine": 92
                }
              }
            }
          ],
          "message": {
            "text": "'input_line' leaves a '\\r' (CR) character when reading lines from a Windows text file, whose lines end in \"\\r\\n\" (CRLF). This is a problem for any Windows file that is being read either on a Unix-like platform or on Windows in binary mode. If the code already takes care of removing any trailing '\\r' after reading the line, add a '(* nosemgrep *)' comment to disable this warning."
          },
          "properties": {},
          "ruleId": "ocaml.lang.portability.crlf-support.broken-input-line"
        },
        {
          "fingerprints": {
            "matchBasedId/v1": "b59ddee5930a65d0fa9cc387b436e6560e3f1ad2d9e6c06befdb762960e2d86ed21d5ba463e44db3371dab355c2815e7c8e82051cef80e9191e2ad00d7b35203_0"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/utils.ml",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "endColumn": 28,
                  "endLine": 92,
                  "snippet": {
                    "text": "      try Some ((input_line ic) ^ \"\\n\") with End_of_file -> None in"
                  },
                  "startColumn": 18,
                  "startLine": 92
                }
              }
            }
          ],
          "message": {
            "text": "'input_line' leaves a '\\r' (CR) character when reading lines from a Windows text file, whose lines end in \"\\r\\n\" (CRLF). This is a problem for any Windows file that is being read either on a Unix-like platform or on Windows in binary mode. If the code already takes care of removing any trailing '\\r' after reading the line, add a '(* nosemgrep *)' comment to disable this warning."
          },
          "properties": {},
          "ruleId": "ocaml.lang.portability.crlf-support.broken-input-line"
        },
        {
          "fingerprints": {
            "matchBasedId/v1": "a1fdae9fd5be5d9a1c25d8ef362e9edd6e3386945851f1d13b2fe7d286f9186232392749400a8c7a26cfb9ff6023bd0f91eefb96d4061988b79d3193831a9d43_0"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "_build/default/src/utils.ml",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "endColumn": 18,
                  "endLine": 105,
                  "snippet": {
                    "text": "  let c = open_in filename in"
                  },
                  "startColumn": 11,
                  "startLine": 105
                }
              }
            }
          ],
          "message": {
            "text": "'open_in' behaves differently on Windows and on Unix-like systems with respect to line endings. To get the same behavior everywhere, use 'open_in_bin' or 'open_in_gen [Open_binary]'. If you really want CRLF-to-LF translations to take place when running on Windows, use 'open_in_gen [Open_text]'."
          },
          "properties": {},
          "ruleId": "ocaml.lang.portability.crlf-support.prefer-read-in-binary-mode"
        },
        {
          "fingerprints": {
            "matchBasedId/v1": "2b388f87894e15a1fe322ae7d7a6fed1373e4c8c00103d5daae50e86e5f0b169f0639ef8b9115a226353a0963a869470392585a7d2743cdc56aefc3be31bd1c8_0"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/utils.ml",
                  "uriBaseId": "%SRCROOT%"
                },
                "region": {
                  "endColumn": 18,
                  "endLine": 105,
                  "snippet": {
                    "text": "  let c = open_in filename in"
                  },
                  "startColumn": 11,
                  "startLine": 105
                }
              }
            }
          ],
          "message": {
            "text": "'open_in' behaves differently on Windows and on Unix-like systems with respect to line endings. To get the same behavior everywhere, use 'open_in_bin' or 'open_in_gen [Open_binary]'. If you really want CRLF-to-LF translations to take place when running on Windows, use 'open_in_gen [Open_text]'."
          },
          "properties": {},
          "ruleId": "ocaml.lang.portability.crlf-support.prefer-read-in-binary-mode"
        }
      ],
      "tool": {
        "driver": {
          "name": "semgrep",
          "rules": [
            {
              "defaultConfiguration": {
                "level": "warning"
              },
              "fullDescription": {
                "text": "'open_in' behaves differently on Windows and on Unix-like systems with respect to line endings. To get the same behavior everywhere, use 'open_in_bin' or 'open_in_gen [Open_binary]'. If you really want CRLF-to-LF translations to take place when running on Windows, use 'open_in_gen [Open_text]'."
              },
              "help": {
                "markdown": "'open_in' behaves differently on Windows and on Unix-like systems with respect to line endings. To get the same behavior everywhere, use 'open_in_bin' or 'open_in_gen [Open_binary]'. If you really want CRLF-to-LF translations to take place when running on Windows, use 'open_in_gen [Open_text]'.\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/ocaml.lang.portability.crlf-support.prefer-read-in-binary-mode)\n",
                "text": "'open_in' behaves differently on Windows and on Unix-like systems with respect to line endings. To get the same behavior everywhere, use 'open_in_bin' or 'open_in_gen [Open_binary]'. If you really want CRLF-to-LF translations to take place when running on Windows, use 'open_in_gen [Open_text]'."
              },
              "helpUri": "https://semgrep.dev/r/ocaml.lang.portability.crlf-support.prefer-read-in-binary-mode",
              "id": "ocaml.lang.portability.crlf-support.prefer-read-in-binary-mode",
              "name": "ocaml.lang.portability.crlf-support.prefer-read-in-binary-mode",
              "properties": {
                "precision": "very-high",
                "tags": [
                  "rule-board-audit"
                ]
              },
              "shortDescription": {
                "text": "Semgrep Finding: ocaml.lang.portability.crlf-support.prefer-read-in-binary-mode"
              }
            },
            {
              "defaultConfiguration": {
                "level": "warning"
              },
              "fullDescription": {
                "text": "You probably want the structural inequality operator ="
              },
              "help": {
                "markdown": "You probably want the structural inequality operator =\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/ocaml.lang.correctness.physical_vs_structural.physical-equal)\n",
                "text": "You probably want the structural inequality operator ="
              },
              "helpUri": "https://semgrep.dev/r/ocaml.lang.correctness.physical_vs_structural.physical-equal",
              "id": "ocaml.lang.correctness.physical_vs_structural.physical-equal",
              "name": "ocaml.lang.correctness.physical_vs_structural.physical-equal",
              "properties": {
                "precision": "very-high",
                "tags": [
                  "rule-board-audit"
                ]
              },
              "shortDescription": {
                "text": "Semgrep Finding: ocaml.lang.correctness.physical_vs_structural.physical-equal"
              }
            },
            {
              "defaultConfiguration": {
                "level": "warning"
              },
              "fullDescription": {
                "text": "You probably want the structural equality operator ="
              },
              "help": {
                "markdown": "You probably want the structural equality operator =\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/ocaml.lang.correctness.physical-vs-structural.physical-equal)\n - [https://v2.ocaml.org/api/Stdlib.html#1_Comparisons](https://v2.ocaml.org/api/Stdlib.html#1_Comparisons)\n",
                "text": "You probably want the structural equality operator ="
              },
              "helpUri": "https://semgrep.dev/r/ocaml.lang.correctness.physical-vs-structural.physical-equal",
              "id": "ocaml.lang.correctness.physical-vs-structural.physical-equal",
              "name": "ocaml.lang.correctness.physical-vs-structural.physical-equal",
              "properties": {
                "precision": "very-high",
                "tags": [
                  "rule-board-audit"
                ]
              },
              "shortDescription": {
                "text": "Semgrep Finding: ocaml.lang.correctness.physical-vs-structural.physical-equal"
              }
            },
            {
              "defaultConfiguration": {
                "level": "warning"
              },
              "fullDescription": {
                "text": "'input_line' leaves a '\\r' (CR) character when reading lines from a Windows text file, whose lines end in \"\\r\\n\" (CRLF). This is a problem for any Windows file that is being read either on a Unix-like platform or on Windows in binary mode. If the code already takes care of removing any trailing '\\r' after reading the line, add a '(* nosemgrep *)' comment to disable this warning."
              },
              "help": {
                "markdown": "'input_line' leaves a '\\r' (CR) character when reading lines from a Windows text file, whose lines end in \"\\r\\n\" (CRLF). This is a problem for any Windows file that is being read either on a Unix-like platform or on Windows in binary mode. If the code already takes care of removing any trailing '\\r' after reading the line, add a '(* nosemgrep *)' comment to disable this warning.\n\n<b>References:</b>\n - [Semgrep Rule](https://semgrep.dev/r/ocaml.lang.portability.crlf-support.broken-input-line)\n",
                "text": "'input_line' leaves a '\\r' (CR) character when reading lines from a Windows text file, whose lines end in \"\\r\\n\" (CRLF). This is a problem for any Windows file that is being read either on a Unix-like platform or on Windows in binary mode. If the code already takes care of removing any trailing '\\r' after reading the line, add a '(* nosemgrep *)' comment to disable this warning."
              },
              "helpUri": "https://semgrep.dev/r/ocaml.lang.portability.crlf-support.broken-input-line",
              "id": "ocaml.lang.portability.crlf-support.broken-input-line",
              "name": "ocaml.lang.portability.crlf-support.broken-input-line",
              "properties": {
                "precision": "very-high",
                "tags": [
                  "rule-board-audit"
                ]
              },
              "shortDescription": {
                "text": "Semgrep Finding: ocaml.lang.portability.crlf-support.broken-input-line"
              }
            }
          ],
          "semanticVersion": "1.26.0"
        }
      }
    }
  ],
  "version": "2.1.0"
}
